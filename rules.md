1. Always seek the simplest and most direct solution possible (KISS principle)
2. Prefer readable code over "clever" or overly compact code
3. Avoid over-engineering - don't add unrequested features
4. Implement only what's necessary to solve the current problem
5. Use descriptive and clear variable names
6. Keep functions small with single responsibilities
7. Separate concerns: business logic, presentation, and data access should be in distinct layers (SoC)
8. Comment only when code isn't self-explanatory
9. Follow the conventions of the language/framework you're using
10. Maintain consistency with existing project code
11. Use consistent indentation and formatting
12. Implement error handling in all critical operations
13. Provide clear and helpful error messages
14. Validate inputs before processing them
15. Use try-catch/error boundaries as appropriate
16. Never silently hide errors
17. Optimize only when necessary and measurable
18. Don't sacrifice readability for premature optimizations
19. Consider resource impact (memory, CPU)
20. Avoid unnecessary expensive operations in loops
21. Use appropriate data structures for each case
22. Never expose credentials or sensitive information in code
23. Validate and sanitize all user inputs
24. Use secure practices (prevent SQL injection, XSS, etc.)
25. Don't trust client data without validation
26. Implement authentication and authorization when necessary
27. Keep dependencies updated and use specific versions
28. Confirm you understand the problem correctly
29. Propose the simplest solution that meets the requirement
30. If there are multiple approaches, explain options and trade-offs
31. Ask if something isn't clear before starting
32. Write incremental and testable code
33. Refactor when you see duplicated or confusing code
34. Test the code before considering it finished
35. Explain what you're going to do before doing it
36. Report problems or limitations encountered
37. Suggest improvements when appropriate
38. Be clear about what works and what doesn't
39. Verify edge cases and boundary situations
40. Test with real data when possible
41. Validate expected behavior before delivering
42. Document important design decisions
43. Keep the README updated with clear instructions
44. Document APIs and public functions
45. Explain the "why" not just the "what"
46. Create descriptive commit messages following conventions (type: description)
